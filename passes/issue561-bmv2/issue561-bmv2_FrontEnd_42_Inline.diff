--- before_pass
+++ after_pass
@@ -86,67 +86,11 @@ struct Tcp_option_sack_top {
     bit<8> kind;
     bit<8> length;
 }
-parser Tcp_option_parser(packet_in b, in bit<4> tcp_hdr_data_offset, out Tcp_option_stack vec, out Tcp_option_padding_h padding) {
-    bit<7> tcp_hdr_bytes_left_0;
-    bit<8> n_sack_bytes_0;
-    bit<8> tmp;
-    Tcp_option_sack_top tmp_0;
-    state start {
-        verify(tcp_hdr_data_offset >= 4w5, error.TcpDataOffsetTooSmall);
-        tcp_hdr_bytes_left_0 = (bit<7>)(tcp_hdr_data_offset + 4w11) << 2;
-        transition next_option;
-    }
-    state next_option {
-        transition select(tcp_hdr_bytes_left_0) {
-            7w0: accept;
-            default: next_option_part2;
-        }
-    }
-    state next_option_part2 {
-        tmp = b.lookahead<bit<8>>();
-        transition select(tmp) {
-            8w0: parse_tcp_option_end;
-            8w1: parse_tcp_option_nop;
-            8w2: parse_tcp_option_ss;
-            8w3: parse_tcp_option_s;
-            8w5: parse_tcp_option_sack;
-        }
-    }
-    state parse_tcp_option_end {
-        b.extract<Tcp_option_end_h>(vec.next.end);
-        tcp_hdr_bytes_left_0 = tcp_hdr_bytes_left_0 + 7w127;
-        b.extract<Tcp_option_padding_h>(padding, (bit<32>)((bit<9>)tcp_hdr_bytes_left_0 << 3));
-        transition accept;
-    }
-    state parse_tcp_option_nop {
-        b.extract<Tcp_option_nop_h>(vec.next.nop);
-        tcp_hdr_bytes_left_0 = tcp_hdr_bytes_left_0 + 7w127;
-        transition next_option;
-    }
-    state parse_tcp_option_ss {
-        verify(tcp_hdr_bytes_left_0 >= 7w5, error.TcpOptionTooLongForHeader);
-        tcp_hdr_bytes_left_0 = tcp_hdr_bytes_left_0 + 7w123;
-        b.extract<Tcp_option_ss_h>(vec.next.ss);
-        transition next_option;
-    }
-    state parse_tcp_option_s {
-        verify(tcp_hdr_bytes_left_0 >= 7w4, error.TcpOptionTooLongForHeader);
-        tcp_hdr_bytes_left_0 = tcp_hdr_bytes_left_0 + 7w124;
-        b.extract<Tcp_option_s_h>(vec.next.s);
-        transition next_option;
-    }
-    state parse_tcp_option_sack {
-        tmp_0 = b.lookahead<Tcp_option_sack_top>();
-        n_sack_bytes_0 = tmp_0.length;
-        verify(n_sack_bytes_0 == 8w10 || n_sack_bytes_0 == 8w18 || n_sack_bytes_0 == 8w26 || n_sack_bytes_0 == 8w34, error.TcpBadSackOptionLength);
-        verify(tcp_hdr_bytes_left_0 >= (bit<7>)n_sack_bytes_0, error.TcpOptionTooLongForHeader);
-        tcp_hdr_bytes_left_0 = tcp_hdr_bytes_left_0 - (bit<7>)n_sack_bytes_0;
-        b.extract<Tcp_option_sack_h>(vec.next.sack, (bit<32>)((n_sack_bytes_0 << 3) + 8w240));
-        transition next_option;
-    }
-}
 parser ParserImpl(packet_in packet, out headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) {
-    @name("Tcp_option_parser") Tcp_option_parser() Tcp_option_parser_inst_0;
+    bit<7> Tcp_option_parser_tcp_hdr_bytes_left;
+    bit<8> Tcp_option_parser_n_sack_bytes;
+    bit<8> Tcp_option_parser_tmp;
+    Tcp_option_sack_top Tcp_option_parser_tmp_0;
     state start {
         packet.extract<ethernet_t>(hdr.ethernet);
         transition select(hdr.ethernet.etherType) {
@@ -163,7 +107,113 @@ parser ParserImpl(packet_in packet, out
     }
     state parse_tcp {
         packet.extract<tcp_t>(hdr.tcp);
-        Tcp_option_parser_inst_0.apply(packet, hdr.tcp.dataOffset, hdr.tcp_options_vec, hdr.tcp_options_padding);
+        hdr.tcp_options_vec[0].end.setInvalid();
+        hdr.tcp_options_vec[0].nop.setInvalid();
+        hdr.tcp_options_vec[0].ss.setInvalid();
+        hdr.tcp_options_vec[0].s.setInvalid();
+        hdr.tcp_options_vec[0].sack.setInvalid();
+        hdr.tcp_options_vec[1].end.setInvalid();
+        hdr.tcp_options_vec[1].nop.setInvalid();
+        hdr.tcp_options_vec[1].ss.setInvalid();
+        hdr.tcp_options_vec[1].s.setInvalid();
+        hdr.tcp_options_vec[1].sack.setInvalid();
+        hdr.tcp_options_vec[2].end.setInvalid();
+        hdr.tcp_options_vec[2].nop.setInvalid();
+        hdr.tcp_options_vec[2].ss.setInvalid();
+        hdr.tcp_options_vec[2].s.setInvalid();
+        hdr.tcp_options_vec[2].sack.setInvalid();
+        hdr.tcp_options_vec[3].end.setInvalid();
+        hdr.tcp_options_vec[3].nop.setInvalid();
+        hdr.tcp_options_vec[3].ss.setInvalid();
+        hdr.tcp_options_vec[3].s.setInvalid();
+        hdr.tcp_options_vec[3].sack.setInvalid();
+        hdr.tcp_options_vec[4].end.setInvalid();
+        hdr.tcp_options_vec[4].nop.setInvalid();
+        hdr.tcp_options_vec[4].ss.setInvalid();
+        hdr.tcp_options_vec[4].s.setInvalid();
+        hdr.tcp_options_vec[4].sack.setInvalid();
+        hdr.tcp_options_vec[5].end.setInvalid();
+        hdr.tcp_options_vec[5].nop.setInvalid();
+        hdr.tcp_options_vec[5].ss.setInvalid();
+        hdr.tcp_options_vec[5].s.setInvalid();
+        hdr.tcp_options_vec[5].sack.setInvalid();
+        hdr.tcp_options_vec[6].end.setInvalid();
+        hdr.tcp_options_vec[6].nop.setInvalid();
+        hdr.tcp_options_vec[6].ss.setInvalid();
+        hdr.tcp_options_vec[6].s.setInvalid();
+        hdr.tcp_options_vec[6].sack.setInvalid();
+        hdr.tcp_options_vec[7].end.setInvalid();
+        hdr.tcp_options_vec[7].nop.setInvalid();
+        hdr.tcp_options_vec[7].ss.setInvalid();
+        hdr.tcp_options_vec[7].s.setInvalid();
+        hdr.tcp_options_vec[7].sack.setInvalid();
+        hdr.tcp_options_vec[8].end.setInvalid();
+        hdr.tcp_options_vec[8].nop.setInvalid();
+        hdr.tcp_options_vec[8].ss.setInvalid();
+        hdr.tcp_options_vec[8].s.setInvalid();
+        hdr.tcp_options_vec[8].sack.setInvalid();
+        hdr.tcp_options_vec[9].end.setInvalid();
+        hdr.tcp_options_vec[9].nop.setInvalid();
+        hdr.tcp_options_vec[9].ss.setInvalid();
+        hdr.tcp_options_vec[9].s.setInvalid();
+        hdr.tcp_options_vec[9].sack.setInvalid();
+        hdr.tcp_options_padding.setInvalid();
+        transition Tcp_option_parser_start;
+    }
+    state Tcp_option_parser_start {
+        verify(hdr.tcp.dataOffset >= 4w5, error.TcpDataOffsetTooSmall);
+        Tcp_option_parser_tcp_hdr_bytes_left = (bit<7>)(hdr.tcp.dataOffset + 4w11) << 2;
+        transition Tcp_option_parser_next_option;
+    }
+    state Tcp_option_parser_next_option {
+        transition select(Tcp_option_parser_tcp_hdr_bytes_left) {
+            7w0: parse_tcp_0;
+            default: Tcp_option_parser_next_option_part2;
+        }
+    }
+    state Tcp_option_parser_next_option_part2 {
+        Tcp_option_parser_tmp = packet.lookahead<bit<8>>();
+        transition select(Tcp_option_parser_tmp) {
+            8w0: Tcp_option_parser_parse_tcp_option_end;
+            8w1: Tcp_option_parser_parse_tcp_option_nop;
+            8w2: Tcp_option_parser_parse_tcp_option_ss;
+            8w3: Tcp_option_parser_parse_tcp_option_s;
+            8w5: Tcp_option_parser_parse_tcp_option_sack;
+        }
+    }
+    state Tcp_option_parser_parse_tcp_option_end {
+        packet.extract<Tcp_option_end_h>(hdr.tcp_options_vec.next.end);
+        Tcp_option_parser_tcp_hdr_bytes_left = Tcp_option_parser_tcp_hdr_bytes_left + 7w127;
+        packet.extract<Tcp_option_padding_h>(hdr.tcp_options_padding, (bit<32>)((bit<9>)Tcp_option_parser_tcp_hdr_bytes_left << 3));
+        transition parse_tcp_0;
+    }
+    state Tcp_option_parser_parse_tcp_option_nop {
+        packet.extract<Tcp_option_nop_h>(hdr.tcp_options_vec.next.nop);
+        Tcp_option_parser_tcp_hdr_bytes_left = Tcp_option_parser_tcp_hdr_bytes_left + 7w127;
+        transition Tcp_option_parser_next_option;
+    }
+    state Tcp_option_parser_parse_tcp_option_ss {
+        verify(Tcp_option_parser_tcp_hdr_bytes_left >= 7w5, error.TcpOptionTooLongForHeader);
+        Tcp_option_parser_tcp_hdr_bytes_left = Tcp_option_parser_tcp_hdr_bytes_left + 7w123;
+        packet.extract<Tcp_option_ss_h>(hdr.tcp_options_vec.next.ss);
+        transition Tcp_option_parser_next_option;
+    }
+    state Tcp_option_parser_parse_tcp_option_s {
+        verify(Tcp_option_parser_tcp_hdr_bytes_left >= 7w4, error.TcpOptionTooLongForHeader);
+        Tcp_option_parser_tcp_hdr_bytes_left = Tcp_option_parser_tcp_hdr_bytes_left + 7w124;
+        packet.extract<Tcp_option_s_h>(hdr.tcp_options_vec.next.s);
+        transition Tcp_option_parser_next_option;
+    }
+    state Tcp_option_parser_parse_tcp_option_sack {
+        Tcp_option_parser_tmp_0 = packet.lookahead<Tcp_option_sack_top>();
+        Tcp_option_parser_n_sack_bytes = Tcp_option_parser_tmp_0.length;
+        verify(Tcp_option_parser_n_sack_bytes == 8w10 || Tcp_option_parser_n_sack_bytes == 8w18 || Tcp_option_parser_n_sack_bytes == 8w26 || Tcp_option_parser_n_sack_bytes == 8w34, error.TcpBadSackOptionLength);
+        verify(Tcp_option_parser_tcp_hdr_bytes_left >= (bit<7>)Tcp_option_parser_n_sack_bytes, error.TcpOptionTooLongForHeader);
+        Tcp_option_parser_tcp_hdr_bytes_left = Tcp_option_parser_tcp_hdr_bytes_left - (bit<7>)Tcp_option_parser_n_sack_bytes;
+        packet.extract<Tcp_option_sack_h>(hdr.tcp_options_vec.next.sack, (bit<32>)((Tcp_option_parser_n_sack_bytes << 3) + 8w240));
+        transition Tcp_option_parser_next_option;
+    }
+    state parse_tcp_0 {
         transition accept;
     }
 }

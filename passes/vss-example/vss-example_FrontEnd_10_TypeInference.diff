--- before_pass
+++ after_pass
@@ -9,14 +9,14 @@ const PortId REAL_PORT_COUNT = 4w8;
 struct InControl {
     PortId inputPort;
 }
-const PortId RECIRCULATE_IN_PORT = 0xd;
-const PortId CPU_IN_PORT = 0xe;
+const PortId RECIRCULATE_IN_PORT = (bit<4>)4w0xd;
+const PortId CPU_IN_PORT = (bit<4>)4w0xe;
 struct OutControl {
     PortId outputPort;
 }
-const PortId DROP_PORT = 0xf;
-const PortId CPU_OUT_PORT = 0xe;
-const PortId RECIRCULATE_OUT_PORT = 0xd;
+const PortId DROP_PORT = (bit<4>)4w0xf;
+const PortId CPU_OUT_PORT = (bit<4>)4w0xe;
+const PortId RECIRCULATE_OUT_PORT = (bit<4>)4w0xd;
 parser Parser<H>(packet_in b, out H parsedHeaders);
 control Pipe<H>(inout H headers, in error parseError, in InControl inCtrl, out OutControl outCtrl);
 control Deparser<H>(inout H outputHeaders, packet_out b);
@@ -57,7 +57,7 @@ parser TopParser(packet_in b, out Parsed
     state start {
         b.extract(p.ethernet);
         transition select(p.ethernet.etherType) {
-            0x800: parse_ipv4;
+            16w0x800: parse_ipv4;
         }
     }
     state parse_ipv4 {
@@ -77,7 +77,7 @@ control TopPipe(inout Parsed_packet head
     IPv4Address nextHop;
     action Set_nhop(IPv4Address ipv4_dest, PortId port) {
         nextHop = ipv4_dest;
-        headers.ip.ttl = headers.ip.ttl - 1;
+        headers.ip.ttl = headers.ip.ttl - 8w1;
         outCtrl.outputPort = port;
     }
     table ipv4_match {

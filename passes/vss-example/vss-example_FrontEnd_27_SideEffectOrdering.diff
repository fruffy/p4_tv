--- before_pass
+++ after_pass
@@ -48,31 +48,59 @@ struct Parsed_packet {
 }
 parser TopParser(packet_in b, out Parsed_packet p) {
     @name("ck") Ck16() ck_0;
+    bit<16> tmp;
+    bool tmp_0;
+    bool tmp_1;
     state start {
-        b.extract<Ethernet_h>(p.ethernet);
+        {
+            b.extract<Ethernet_h>(p.ethernet);
+        }
         transition select(p.ethernet.etherType) {
             16w0x800: parse_ipv4;
         }
     }
     state parse_ipv4 {
-        b.extract<Ipv4_h>(p.ip);
-        verify(p.ip.version == 4w4, error.IPv4IncorrectVersion);
-        verify(p.ip.ihl == 4w5, error.IPv4OptionsNotSupported);
-        ck_0.clear();
-        ck_0.update<Ipv4_h>(p.ip);
-        verify(ck_0.get() == 16w0, error.IPv4ChecksumError);
+        {
+            b.extract<Ipv4_h>(p.ip);
+        }
+        {
+            verify(p.ip.version == 4w4, error.IPv4IncorrectVersion);
+        }
+        {
+            verify(p.ip.ihl == 4w5, error.IPv4OptionsNotSupported);
+        }
+        {
+            ck_0.clear();
+        }
+        {
+            ck_0.update<Ipv4_h>(p.ip);
+        }
+        {
+            tmp = ck_0.get();
+            tmp_0 = tmp == 16w0;
+            tmp_1 = tmp_0;
+            verify(tmp_1, error.IPv4ChecksumError);
+        }
         transition accept;
     }
 }
 control TopPipe(inout Parsed_packet headers, in error parseError, in InControl inCtrl, out OutControl outCtrl) {
     IPv4Address nextHop_0;
     @name("Drop_action") action Drop_action_0() {
-        outCtrl.outputPort = 4w0xf;
+        {
+            outCtrl.outputPort = 4w0xf;
+        }
     }
     @name("Set_nhop") action Set_nhop_0(IPv4Address ipv4_dest, PortId port) {
-        nextHop_0 = ipv4_dest;
-        headers.ip.ttl = headers.ip.ttl + 8w255;
-        outCtrl.outputPort = port;
+        {
+            nextHop_0 = ipv4_dest;
+        }
+        {
+            headers.ip.ttl = headers.ip.ttl + 8w255;
+        }
+        {
+            outCtrl.outputPort = port;
+        }
     }
     @name("ipv4_match") table ipv4_match_0 {
         key = {
@@ -86,7 +114,9 @@ control TopPipe(inout Parsed_packet head
         default_action = Drop_action_0();
     }
     @name("Send_to_cpu") action Send_to_cpu_0() {
-        outCtrl.outputPort = 4w0xe;
+        {
+            outCtrl.outputPort = 4w0xe;
+        }
     }
     @name("check_ttl") table check_ttl_0 {
         key = {
@@ -99,7 +129,9 @@ control TopPipe(inout Parsed_packet head
         const default_action = NoAction();
     }
     @name("Set_dmac") action Set_dmac_0(EthernetAddress dmac) {
-        headers.ethernet.dstAddr = dmac;
+        {
+            headers.ethernet.dstAddr = dmac;
+        }
     }
     @name("dmac") table dmac_0 {
         key = {
@@ -113,7 +145,9 @@ control TopPipe(inout Parsed_packet head
         default_action = Drop_action_0();
     }
     @name("Set_smac") action Set_smac_0(EthernetAddress smac) {
-        headers.ethernet.srcAddr = smac;
+        {
+            headers.ethernet.srcAddr = smac;
+        }
     }
     @name("smac") table smac_0 {
         key = {
@@ -128,35 +162,59 @@ control TopPipe(inout Parsed_packet head
     }
     apply {
         if (parseError != error.NoError) {
-            Drop_action_0();
+            {
+                Drop_action_0();
+            }
             return;
         }
-        ipv4_match_0.apply();
+        {
+            ipv4_match_0.apply();
+        }
         if (outCtrl.outputPort == 4w0xf) {
             return;
         }
-        check_ttl_0.apply();
+        {
+            check_ttl_0.apply();
+        }
         if (outCtrl.outputPort == 4w0xe) {
             return;
         }
-        dmac_0.apply();
+        {
+            dmac_0.apply();
+        }
         if (outCtrl.outputPort == 4w0xf) {
             return;
         }
-        smac_0.apply();
+        {
+            smac_0.apply();
+        }
     }
 }
 control TopDeparser(inout Parsed_packet p, packet_out b) {
     @name("ck") Ck16() ck_1;
+    bit<16> tmp_2;
     apply {
-        b.emit<Ethernet_h>(p.ethernet);
+        {
+            b.emit<Ethernet_h>(p.ethernet);
+        }
         if (p.ip.isValid()) {
-            ck_1.clear();
-            p.ip.hdrChecksum = 16w0;
-            ck_1.update<Ipv4_h>(p.ip);
-            p.ip.hdrChecksum = ck_1.get();
+            {
+                ck_1.clear();
+            }
+            {
+                p.ip.hdrChecksum = 16w0;
+            }
+            {
+                ck_1.update<Ipv4_h>(p.ip);
+            }
+            {
+                tmp_2 = ck_1.get();
+                p.ip.hdrChecksum = tmp_2;
+            }
+        }
+        {
+            b.emit<Ipv4_h>(p.ip);
         }
-        b.emit<Ipv4_h>(p.ip);
     }
 }
 VSS<Parsed_packet>(TopParser(), TopPipe(), TopDeparser()) main;

--- before_pass
+++ after_pass
@@ -47,7 +47,7 @@ struct Parsed_packet {
     Ipv4_h     ip;
 }
 parser TopParser(packet_in b, out Parsed_packet p) {
-    Ck16() ck;
+    @name("ck") Ck16() ck_0;
     state start {
         b.extract<Ethernet_h>(p.ethernet);
         transition select(p.ethernet.etherType) {
@@ -58,103 +58,103 @@ parser TopParser(packet_in b, out Parsed
         b.extract<Ipv4_h>(p.ip);
         verify(p.ip.version == 4w4, error.IPv4IncorrectVersion);
         verify(p.ip.ihl == 4w5, error.IPv4OptionsNotSupported);
-        ck.clear();
-        ck.update<Ipv4_h>(p.ip);
-        verify(ck.get() == 16w0, error.IPv4ChecksumError);
+        ck_0.clear();
+        ck_0.update<Ipv4_h>(p.ip);
+        verify(ck_0.get() == 16w0, error.IPv4ChecksumError);
         transition accept;
     }
 }
 control TopPipe(inout Parsed_packet headers, in error parseError, in InControl inCtrl, out OutControl outCtrl) {
-    action Drop_action() {
+    @name("Drop_action") action Drop_action_0() {
         outCtrl.outputPort = 4w0xf;
     }
-    IPv4Address nextHop;
-    action Set_nhop(IPv4Address ipv4_dest, PortId port) {
-        nextHop = ipv4_dest;
+    IPv4Address nextHop_0;
+    @name("Set_nhop") action Set_nhop_0(IPv4Address ipv4_dest, PortId port) {
+        nextHop_0 = ipv4_dest;
         headers.ip.ttl = headers.ip.ttl + 8w255;
         outCtrl.outputPort = port;
     }
-    table ipv4_match {
+    @name("ipv4_match") table ipv4_match_0 {
         key = {
             headers.ip.dstAddr: lpm @name("headers.ip.dstAddr") ;
         }
         actions = {
-            Drop_action();
-            Set_nhop();
+            Drop_action_0();
+            Set_nhop_0();
         }
         size = 1024;
-        default_action = Drop_action();
+        default_action = Drop_action_0();
     }
-    action Send_to_cpu() {
+    @name("Send_to_cpu") action Send_to_cpu_0() {
         outCtrl.outputPort = 4w0xe;
     }
-    table check_ttl {
+    @name("check_ttl") table check_ttl_0 {
         key = {
             headers.ip.ttl: exact @name("headers.ip.ttl") ;
         }
         actions = {
-            Send_to_cpu();
+            Send_to_cpu_0();
             NoAction();
         }
         const default_action = NoAction();
     }
-    action Set_dmac(EthernetAddress dmac) {
+    @name("Set_dmac") action Set_dmac_0(EthernetAddress dmac) {
         headers.ethernet.dstAddr = dmac;
     }
-    table dmac {
+    @name("dmac") table dmac_0 {
         key = {
-            nextHop: exact @name("nextHop") ;
+            nextHop_0: exact @name("nextHop") ;
         }
         actions = {
-            Drop_action();
-            Set_dmac();
+            Drop_action_0();
+            Set_dmac_0();
         }
         size = 1024;
-        default_action = Drop_action();
+        default_action = Drop_action_0();
     }
-    action Set_smac(EthernetAddress smac) {
+    @name("Set_smac") action Set_smac_0(EthernetAddress smac) {
         headers.ethernet.srcAddr = smac;
     }
-    table smac {
+    @name("smac") table smac_0 {
         key = {
             outCtrl.outputPort: exact @name("outCtrl.outputPort") ;
         }
         actions = {
-            Drop_action();
-            Set_smac();
+            Drop_action_0();
+            Set_smac_0();
         }
         size = 16;
-        default_action = Drop_action();
+        default_action = Drop_action_0();
     }
     apply {
         if (parseError != error.NoError) {
-            Drop_action();
+            Drop_action_0();
             return;
         }
-        ipv4_match.apply();
+        ipv4_match_0.apply();
         if (outCtrl.outputPort == 4w0xf) {
             return;
         }
-        check_ttl.apply();
+        check_ttl_0.apply();
         if (outCtrl.outputPort == 4w0xe) {
             return;
         }
-        dmac.apply();
+        dmac_0.apply();
         if (outCtrl.outputPort == 4w0xf) {
             return;
         }
-        smac.apply();
+        smac_0.apply();
     }
 }
 control TopDeparser(inout Parsed_packet p, packet_out b) {
-    Ck16() ck;
+    @name("ck") Ck16() ck_1;
     apply {
         b.emit<Ethernet_h>(p.ethernet);
         if (p.ip.isValid()) {
-            ck.clear();
+            ck_1.clear();
             p.ip.hdrChecksum = 16w0;
-            ck.update<Ipv4_h>(p.ip);
-            p.ip.hdrChecksum = ck.get();
+            ck_1.update<Ipv4_h>(p.ip);
+            p.ip.hdrChecksum = ck_1.get();
         }
         b.emit<Ipv4_h>(p.ip);
     }

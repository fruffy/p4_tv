--- before_pass
+++ after_pass
@@ -47,10 +47,10 @@ struct Parsed_packet {
     Ipv4_h     ip;
 }
 parser TopParser(packet_in b, out Parsed_packet p) {
-    bit<16> tmp_3;
-    bool tmp_4;
-    bool tmp_5;
-    @name("ck") Ck16() ck;
+    bit<16> tmp;
+    bool tmp_0;
+    bool tmp_1;
+    @name("ck") Ck16() ck_0;
     state start {
         b.extract<Ethernet_h>(p.ethernet);
         transition select(p.ethernet.etherType) {
@@ -61,128 +61,128 @@ parser TopParser(packet_in b, out Parsed
         b.extract<Ipv4_h>(p.ip);
         verify(p.ip.version == 4w4, error.IPv4IncorrectVersion);
         verify(p.ip.ihl == 4w5, error.IPv4OptionsNotSupported);
-        ck.clear();
-        ck.update<Ipv4_h>(p.ip);
-        tmp_3 = ck.get();
-        tmp_4 = tmp_3 == 16w0;
-        tmp_5 = tmp_4;
-        verify(tmp_5, error.IPv4ChecksumError);
+        ck_0.clear();
+        ck_0.update<Ipv4_h>(p.ip);
+        tmp = ck_0.get();
+        tmp_0 = tmp == 16w0;
+        tmp_1 = tmp_0;
+        verify(tmp_1, error.IPv4ChecksumError);
         transition accept;
     }
 }
 control TopPipe(inout Parsed_packet headers, in error parseError, in InControl inCtrl, out OutControl outCtrl) {
-    @name(".NoAction") action NoAction_1() {
+    @name(".NoAction") action NoAction_0() {
     }
-    IPv4Address nextHop;
-    @name("Drop_action") action Drop_action_0() {
+    IPv4Address nextHop_0;
+    @name("Drop_action") action Drop_action() {
         outCtrl.outputPort = 4w0xf;
     }
-    @name("Drop_action") action Drop_action_1() {
+    @name("Drop_action") action Drop_action_4() {
         outCtrl.outputPort = 4w0xf;
     }
-    @name("Drop_action") action Drop_action_2() {
+    @name("Drop_action") action Drop_action_5() {
         outCtrl.outputPort = 4w0xf;
     }
-    @name("Drop_action") action Drop_action_3() {
+    @name("Drop_action") action Drop_action_6() {
         outCtrl.outputPort = 4w0xf;
     }
-    @name("Set_nhop") action Set_nhop_0(IPv4Address ipv4_dest, PortId port) {
-        nextHop = ipv4_dest;
+    @name("Set_nhop") action Set_nhop(IPv4Address ipv4_dest, PortId port) {
+        nextHop_0 = ipv4_dest;
         headers.ip.ttl = headers.ip.ttl + 8w255;
         outCtrl.outputPort = port;
     }
-    @name("ipv4_match") table ipv4_match {
+    @name("ipv4_match") table ipv4_match_0 {
         key = {
             headers.ip.dstAddr: lpm @name("headers.ip.dstAddr") ;
         }
         actions = {
-            Drop_action_0();
-            Set_nhop_0();
+            Drop_action();
+            Set_nhop();
         }
         size = 1024;
-        default_action = Drop_action_0();
+        default_action = Drop_action();
     }
-    @name("Send_to_cpu") action Send_to_cpu_0() {
+    @name("Send_to_cpu") action Send_to_cpu() {
         outCtrl.outputPort = 4w0xe;
     }
-    @name("check_ttl") table check_ttl {
+    @name("check_ttl") table check_ttl_0 {
         key = {
             headers.ip.ttl: exact @name("headers.ip.ttl") ;
         }
         actions = {
-            Send_to_cpu_0();
-            NoAction_1();
+            Send_to_cpu();
+            NoAction_0();
         }
-        const default_action = NoAction_1();
+        const default_action = NoAction_0();
     }
-    @name("Set_dmac") action Set_dmac_0(EthernetAddress dmac) {
+    @name("Set_dmac") action Set_dmac(EthernetAddress dmac) {
         headers.ethernet.dstAddr = dmac;
     }
-    @name("dmac") table dmac_1 {
+    @name("dmac") table dmac_0 {
         key = {
-            nextHop: exact @name("nextHop") ;
+            nextHop_0: exact @name("nextHop") ;
         }
         actions = {
-            Drop_action_1();
-            Set_dmac_0();
+            Drop_action_4();
+            Set_dmac();
         }
         size = 1024;
-        default_action = Drop_action_1();
+        default_action = Drop_action_4();
     }
-    @name("Set_smac") action Set_smac_0(EthernetAddress smac) {
+    @name("Set_smac") action Set_smac(EthernetAddress smac) {
         headers.ethernet.srcAddr = smac;
     }
-    @name("smac") table smac_1 {
+    @name("smac") table smac_0 {
         key = {
             outCtrl.outputPort: exact @name("outCtrl.outputPort") ;
         }
         actions = {
-            Drop_action_2();
-            Set_smac_0();
+            Drop_action_5();
+            Set_smac();
         }
         size = 16;
-        default_action = Drop_action_2();
+        default_action = Drop_action_5();
     }
     apply {
-        bool hasReturned_0 = false;
+        bool hasReturned = false;
         if (parseError != error.NoError) {
-            Drop_action_3();
-            hasReturned_0 = true;
+            Drop_action_6();
+            hasReturned = true;
         }
-        if (!hasReturned_0) {
-            ipv4_match.apply();
+        if (!hasReturned) {
+            ipv4_match_0.apply();
             if (outCtrl.outputPort == 4w0xf) {
-                hasReturned_0 = true;
+                hasReturned = true;
             }
         }
-        if (!hasReturned_0) {
-            check_ttl.apply();
+        if (!hasReturned) {
+            check_ttl_0.apply();
             if (outCtrl.outputPort == 4w0xe) {
-                hasReturned_0 = true;
+                hasReturned = true;
             }
         }
-        if (!hasReturned_0) {
-            dmac_1.apply();
+        if (!hasReturned) {
+            dmac_0.apply();
             if (outCtrl.outputPort == 4w0xf) {
-                hasReturned_0 = true;
+                hasReturned = true;
             }
         }
-        if (!hasReturned_0) {
-            smac_1.apply();
+        if (!hasReturned) {
+            smac_0.apply();
         }
     }
 }
 control TopDeparser(inout Parsed_packet p, packet_out b) {
-    bit<16> tmp_6;
-    @name("ck") Ck16() ck_2;
+    bit<16> tmp_2;
+    @name("ck") Ck16() ck_1;
     apply {
         b.emit<Ethernet_h>(p.ethernet);
         if (p.ip.isValid()) {
-            ck_2.clear();
+            ck_1.clear();
             p.ip.hdrChecksum = 16w0;
-            ck_2.update<Ipv4_h>(p.ip);
-            tmp_6 = ck_2.get();
-            p.ip.hdrChecksum = tmp_6;
+            ck_1.update<Ipv4_h>(p.ip);
+            tmp_2 = ck_1.get();
+            p.ip.hdrChecksum = tmp_2;
         }
         b.emit<Ipv4_h>(p.ip);
     }
